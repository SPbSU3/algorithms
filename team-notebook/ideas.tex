\begin{itemize}
    \item 
\foreignlanguage{russian}{[CF 381 Div 1 E] Пусть есть динамика $dp[n][a][b]$ за $O(n^3)$, где мы как-то делаем O(1)
переходов вида добавить значение c за x b-шек, y a-шек. Если при этом оптимальный ответ
всегда в $dp[n][a][b]$, то можно вместо $dp[n][a][b]$ хранить $dp[n][a][b] - c \cdot b$. Это ещё
ничего не даёт само по себе, но позволяеет написать динамику dp[n][a], cnt[n][a] -
подвинутое значение динамики, которого мы добились, а cnt - число использованных при
этом b-шек. Теперь заметим, что большие $c$ заставляют нас избегать b-шек и их используется
больше $b$. Сильно отрицательные заставляют нас набирать b-шки со страшной силой. Нам нужно
найти в точности ту границу, где $cnt[n][a] = b$ и посчитать там.}

\item
\foreignlanguage{russian}{[Задача Tree Embedding с какого-то китайского контеста в Петрозаводске] Естественную
метрику на дереве (расстояние между вершинами есть число рёбер между ними) с n вершинами
можно смоделировать с помошью $l_{\infty}^{O(\log{n})}$ (то есть вектора с $O(\log{n})$ координатами,
что $d(x, y) = max_i |x_i - y_i|$). Ссылка на алгоритм в комментариях
к} http://codeforces.com/blog/entry/49117.

\item
\foreignlanguage{russian}{
[Hackerrank 101 Hack 43, часть задачи E]
Посчитать число способов представить k как сумму различных слагаемых от 1 до $n$ за $O(k^{\frac{3}{2}})$.
Cчитаем динамику $dp[cnt][sum]$ - число способов набрать sum с помощью cnt элементов
(не имеет смысл использовать $cnt$ больше $O(\sqrt{k})$. Считаем так: $dp[i][j] =
dp[i - 1][j - i] + dp[i][j - i] - dp[i - 1][j - n - 1]$ (уменьшим все слагаемые на один, их
осталось либо снова $i$, либо $i - 1$ (ушла единица), при этом посчитали лишние состояния,
где в сумму после уменьшения входило $n$ (а значит в текущую сумму входит $n+1$, что запрещено),
их ровно столько, сколько нормальных состояний с $i - 1$ элементом и суммой $j - n - 1$.
Аналогично, если надо посчитать со знаком $(-1)^{|S|}$. Код для этого случая (со знаком):}
\begin{lstlisting}[language=c++]
forn (i, L + 1) forn (j, k + 1) if (dp[i][j])
{
	add(res[j], dp[i][j]);
	if (i + 1 <= L && j + i + 1 <= k)
		sub(dp[i + 1][j + i + 1], dp[i][j]);
	if (j + i <= k) if (i)
		add(dp[i][j + i], dp[i][j]);
	if (j + n + 1 <= k && i + 1 <= L)
		add(dp[i + 1][j + n + 1], dp[i][j]);
}
\end{lstlisting}

\item
\foreignlanguage{russian}{Число перестановок $n$ элементов
с ровно $k$ инверсиями есть коэффициент при $x^k$ многочлена \\
$(1 + x + x^2 + \ldots + x^{n - 1})(1 + x + x^2 + \ldots + x^{n - 2}) \ldots (1 + x) \cdot 1$ \\
(смотрим на
тупую динамику и радуемся), что есть \\
$(1 - x)^{-n} (1 - x) (1 - x^2) \ldots (1 - x^n)$. \\
Если
$k \leq n$, то можно заменить на \\
$(1 - x)^{-n} \prod\limits_{i = 1}^{+\infty} (1 - x^i) = (1 - x)^{-n} \sum\limits_{q = -\infty}^{+\infty} (-1)^q \cdot x^{3q(q + 1)/2}$ \\
(пентагональная
теорема Эйлера).}

\item
\foreignlanguage{russian}{[Задача с контеста СГУ в ПТЗ зима 2016 про три сервера, задача про покемонов
(см. пост krismaz на CF]. Пусть надо выбрать ровно $k$ объектов из $n$ и есть
какая-то динамика типа $dp[x][y]$ - выбрали ровно $y$ объектов из первых $x$.
(возвращаем $dp[n][k]$). Можно предварительно пошаффлить объекты и тогда
нет смысла рассматривать состояния $dp[x][y]$ с слишком большим
$|y - \frac{xk}{n}|$, так как теперь объекты из оптимального решения распределены
случайно (отклоняемся на $O(\sqrt{n})$).}

\item
\foreignlanguage{russian}{[Opencup GP of Poland 2017, задача A]. Если нужно посчитать число строк, не содержащих
данных в качестве подстрок на фиксированных позиций (похоже на Ахо-Корасик, но не
совсем то же самое), то можно это делать персистентным бором.}

\item
\foreignlanguage{russian}{[Птз-лето 2017, восьмой день, Convex polygons (задача G)]\\
Можно считать $\sum\limits_{y=l}^r p(y) {y \choose x}$, где $p$ - многочлен, разложив
$p$ по базису $1$, $t$, $t(t+1)/2$, $t(t+1)(t+2)/6$, $\ldots$ Например, \\
$\sum\limits_{y=1}^r y \cdot {y \choose x} = \sum\limits_{z=1}^r \sum\limits_{y=z}^r {y \choose x} =
\sum\limits_{z=1}^r ({r+1 \choose x} - {z+1 \choose x})$ и так далее (свернуть ещё раз).}\\
Hockey stick theorem: $\sum\limits_{y=x}^{r} {y \choose x} = {r+1 \choose x+1}$

\item
\foreignlanguage{russian}{Пусть есть некоторая динамика с циклическими зависимостями
(обычно матожидание какого-то времени), которая тем не менее однозначно
выражается через одно из своих значений. Тогда очень часто работает такой
трюк: сделать бинпоиск по этому значению X, а потом поcчитать его по-нормальному,
заменяя все его вызовы на X (и получить Y). Если X < Y, то X меньше ответа,
если X > Y, то X больше ответа.}

\end{itemize}

